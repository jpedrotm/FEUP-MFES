class Celebrity
	types
		public celebrityType = <sport> | <actor> | <comedian> | <tech> |
													<music> | <cook> | <magic>;
	values
	-- TODO Define values here
	instance variables
		private name: Globals`String;
		private type: set of celebrityType;
		private minPrice: nat1;
		private maxTime: nat1;
		private roles: set of Contract`contractRoles;
		private contracts: seq of Contract := [];
		private maxContracts: nat1 := 2;
		inv numActiveContracts() <= maxContracts;
	operations
		public Celebrity: Globals`String*set of celebrityType*nat1*nat1*set of Contract`contractRoles*nat1 ==> Celebrity
			Celebrity(n,celebsTypes,minP,maxT,rs,maxC) == (
				name := n;
		 		type := celebsTypes;
		 		minPrice := minP;
		 		maxTime := maxT;
		 		roles := rs;
		 		maxContracts := maxC;
		 		return self
			)
			pre celebsTypes <> {} and rs <> {} and n <> "" and minP > 0 and maxT > 0 and maxC > 0
			post name = n and type = celebsTypes and minPrice = minP and maxTime = maxT and roles = rs and contracts = [] and maxContracts = maxC;
		
		public getName: () ==> Globals`String
			getName() == return name
			pre name <> ""
			post RESULT = name;
			
		public getType: () ==> set of celebrityType
			getType() == return type
			pre type <> {}
			post RESULT = type;
			
		public getMinPrice: () ==> nat
			getMinPrice() == return minPrice
			pre minPrice >= 0
			post RESULT = minPrice;
			
		public getMaxTime: () ==> nat
			getMaxTime() == return maxTime
			pre maxTime > 0
			post RESULT = maxTime;
			
		public pure getRoles: () ==> set of Contract`contractRoles
			getRoles() == return roles
			pre roles <> {}
			post RESULT = roles;
			
		public getContracts: () ==> seq of Contract
			getContracts() == return contracts
			post RESULT = contracts;
			
		public addContract: Contract ==> ()
			addContract(c) == (
				contracts := contracts ^ [c];
				contracts := Mergesort`sortContracts(contracts);
			)
			pre checkIfContractIsGood(c) and c not in set elems contracts and c.getRole() in set roles
			post contracts = Mergesort`sortContracts(contracts) and numActiveContracts() <= maxContracts;
			
		public removeContract: Contract ==> ()
			removeContract(c) == (
				dcl tmpContracts: seq of Contract := [];
				while len contracts > 0 do
				(
					if hd contracts <> c then
						tmpContracts := tmpContracts ^ [hd contracts];
					
					contracts := tl contracts;
				);
					
				contracts := tmpContracts;
			)
			pre contracts <> [] and c in set elems contracts
			post c not in set elems contracts and len contracts = (len contracts~) - 1;
			
		public pure checkIfContractIsGood: Contract ==> bool
			checkIfContractIsGood(c) == (
				if(c.getDurationTime() <= maxTime and minPrice <= c.getTotalPrice() and len contracts < maxContracts) then
					return true
				else if(c.getDurationTime() <= maxTime and minPrice <= c.getTotalPrice() and hasSpaceForNewContract(c)) then
					return true
				else return false;
			)
			pre c not in set elems contracts;
			
		public pure hasSpaceForNewContract: Contract ==> bool
			hasSpaceForNewContract(c) == (
				dcl numOfDifferentContractDates: nat := 0;
				for all contract in set elems contracts do
					if (Globals`compareDates(contract.getFinalDate(), c.getStartDate()) or Globals`compareDates(c.getFinalDate(),contract.getStartDate())) then
						(
							numOfDifferentContractDates := numOfDifferentContractDates + 1;
						);
											
				return (len contracts - numOfDifferentContractDates) < maxContracts;
			);
			
		public pure numActiveContracts: () ==> nat
			numActiveContracts() == (
				return card {contract | contract in set elems contracts & Globals`compareDates(contract.getStartDate(),Platform`currentDate)
				 and Globals`compareDates(Platform`currentDate,contract.getFinalDate())}
			);
	functions
		
	traces
	-- TODO Define Combinatorial Test Traces here
end Celebrity