class Celebrity
	types
		public celebrityType = <sport> | <actor> | <comedian> | <tech> |
													<music> | <cook> | <magic>;
	values
	-- TODO Define values here
	instance variables
		private name: Utils`String;
		private type: set of celebrityType;
		private minPrice: nat1;
		private maxTime: nat1;
		private roles: map Contract`contractRoles to nat1;
		private contracts: seq of Contract := [];
		private maxContracts: nat1 := 2;
		inv numActiveContracts() <= maxContracts;
	operations
		public Celebrity: Utils`String*set of celebrityType*nat1*nat1*map Contract`contractRoles to nat1*nat1 ==> Celebrity
			Celebrity(n,celebsTypes,minP,maxT,rs,maxC) == (
				name := n;
		 		type := celebsTypes;
		 		minPrice := minP;
		 		maxTime := maxT;
		 		roles := rs;
		 		maxContracts := maxC;
		 		return self
			)
			pre celebsTypes <> {} and rs <> {|->}
			post name = n and type = celebsTypes and minPrice = minP and maxTime = maxT and roles = rs and contracts = [] and maxContracts = maxC; --ver melhor isto
		
		
		public Celebrity: () ==> Celebrity --apenas para testes
			Celebrity() == (roles := {<speaker> |-> 1,<ambassador> |-> 1}; return self);
		
		public getName: () ==> Utils`String
			getName() == return name
			pre name <> ""
			post RESULT = name;
			
		public getType: () ==> set of celebrityType
			getType() == return type
			pre type <> {}
			post RESULT = type;
			
		public getMinPrice: () ==> nat
			getMinPrice() == return minPrice
			pre minPrice >= 0
			post RESULT = minPrice;
			
		public getMaxTime: () ==> nat
			getMaxTime() == return maxTime
			pre maxTime > 0
			post RESULT = maxTime;
			
		public getRoles: () ==> map Contract`contractRoles to nat1
			getRoles() == return roles
			pre roles <> {|->}
			post RESULT = roles;
			
		public getContracts: () ==> seq of Contract
			getContracts() == return contracts
			post RESULT = contracts;
			
		public addContract: Contract ==> ()
			addContract(c) == (
				contracts := contracts ^ [c];
				contracts := Mergesort`sortContracts(contracts);
			)
			pre numActiveContracts() < maxContracts and c not in set elems contracts
			post contracts = Mergesort`sortContracts(contracts); -- talvez mude depois
			
		public removeContract: Contract ==> ()
			removeContract(c) == (
				dcl tmpContracts: seq of Contract := contracts;
				while len contracts > 0 do
				(
					if hd contracts <> c then
						tmpContracts := tmpContracts ^ [hd contracts];
					contracts := tl contracts;
				);
					
				contracts := tmpContracts;
			)
			pre contracts <> [] and c in set elems contracts
			post c not in set elems contracts and len contracts = (len contracts~) - 1;
			
		public checkIfContractIsGood: Contract ==> bool
			checkIfContractIsGood(c) == (
				if(c.getDurationTime() <= maxTime and minPrice >= c.getTotalPrice() and len contracts <= maxContracts) then
					return true
				else if(c.getDurationTime() <= maxTime and minPrice >= c.getTotalPrice() and haveSpaceForNewContract(c)) then
					return true
				else return false;
			)
			pre c not in set elems contracts;
			
		public haveSpaceForNewContract: Contract ==> bool
			haveSpaceForNewContract(c) == (
				dcl numOfDifferentContractDates: nat := 0;
				for all contract in set elems contracts do
					if (Utils`compareDates(contract.getFinalDate(), c.getStartDate()) or Utils`compareDates(c.getFinalDate(),contract.getStartDate())) then
						(
							numOfDifferentContractDates := numOfDifferentContractDates + 1;
						);
											
				return (maxContracts - numOfDifferentContractDates) < maxContracts;
			);
			
		public pure numActiveContracts: () ==> nat
			numActiveContracts() == (
				return card {contract | contract in set elems contracts & Utils`compareDates(contract.getStartDate(),Platform`currentDate)
				 and Utils`compareDates(Platform`currentDate,contract.getFinalDate())}
			);
	functions
		
	traces
	-- TODO Define Combinatorial Test Traces here
end Celebrity