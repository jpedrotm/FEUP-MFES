class Project
types
-- TODO Define types here
	public contractRole = Contract`contractRoles;
	public numForRole = map contractRole to nat1;
	public budgetPerRole = map contractRole to nat1;
	
values
-- TODO Define values here
instance variables
	private name: Globals`String;
	private contracts: seq of Contract;
	private maxNumContracts: nat1;
	private desiredNumPerRole: numForRole;
	private maxPricePerRole: budgetPerRole;
	private desiredCelebTypes: set of Celebrity`celebrityType;
	private duration: nat1;
	inv len contracts <= maxNumContracts; -- the project does not have more contracts than desired
	inv getTotalNumDesiredRoles() <= maxNumContracts;
	inv getTotalNumBudgetedRoles() <= maxNumContracts;
	inv dom desiredNumPerRole = dom maxPricePerRole;
	

-- TODO Define instance variables here
operations
	public Project: Globals`String*nat1*numForRole*budgetPerRole*set of Celebrity`celebrityType*nat1 ==> Project
		Project(n,m,d,b,ct,t) == 
		(
			name := n;
			contracts := [];
			maxNumContracts := m;
			desiredNumPerRole := d;
			maxPricePerRole := b;
			desiredCelebTypes := ct;
			duration := t;
			return self;
		)
		pre d <> {|->} and b <> {|->} and ct <> {} -- The project must specify desired roles, budget for those roles, and desired celebrity types
		post name = n and contracts = [] and maxNumContracts = m and desiredNumPerRole = d and maxPricePerRole = b and desiredCelebTypes = ct and duration = t;
		
	-- ----- Desired Roles ----------------------------------------------
	public getDesiredNumPerRole: () ==> numForRole
		getDesiredNumPerRole() == return desiredNumPerRole;
		
	public getDesiredNumForRole: contractRole ==> nat
		getDesiredNumForRole(role) ==
		(
			if role not in set dom desiredNumPerRole
			then return 0
			else return desiredNumPerRole(role);
		)
		post RESULT >= 0;
		
	public pure getTotalNumDesiredRoles: () ==> nat
		getTotalNumDesiredRoles() == return getSumDesiredRoles(dom desiredNumPerRole, desiredNumPerRole)
		post RESULT >= 0;
		
	-- auxiliary function that returns the sum of all the keys in a map
	public pure  getSumDesiredRoles: set of contractRole*numForRole ==> nat
		getSumDesiredRoles(roles, numRoleMap) == 
		(
			if roles = {}
			then return 0
			else return let role in set roles
				in 
					numRoleMap(role) + getSumDesiredRoles(roles \ {role}, numRoleMap)
		)
		post RESULT >= 0;
		
	public getDesiredRoles: () ==> set of contractRole
		getDesiredRoles() == return dom desiredNumPerRole;
	-- ----- Desired Roles End -------------------------------------------
	
	-- ----- Desired Types -----------------------------------------------
	
	public getDesiredCelebTypes: () ==> set of Celebrity`celebrityType
		getDesiredCelebTypes() == return desiredCelebTypes;	
		
		-- ----- Desired Types End -------------------------------------------
		
	-- ----- Budget ------------------------------------------------------
	public getMaxPriceForRole: contractRole ==> nat
		getMaxPriceForRole(role) ==
		(
			if role not in set dom maxPricePerRole
			then return 0
			else return maxPricePerRole(role);
		)
		post RESULT >= 0;
		
	public getBudgetPerRole: () ==> budgetPerRole
		getBudgetPerRole() == return maxPricePerRole;
		
	public pure getTotalNumBudgetedRoles: () ==> nat
		getTotalNumBudgetedRoles() == return card dom maxPricePerRole
		post RESULT >= 0;
		
	public getBudgetedRoles: () ==> set of contractRole
		getBudgetedRoles() == return dom maxPricePerRole;

	-- ----- Budget End---------------------------------------------------
		
	-- ----- Search celebrity --------------------------------------------
	--public getAppropriateCelebs: set of Celebrity ==> set of Celebrity
	--getAppropriateCelebs(celebs) ==
	--(
	--	return {celeb | celeb in set celebs & (celeb.getRoles() inter getDesiredRoles() <> {|->} and celeb.getType() inter getDesiredCelebTypes() <> {})};
	--)
	
	
-- TODO Define operations here
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Project