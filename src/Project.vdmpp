class Project
types
-- TODO Define types here
	public contractRole = Contract`contractRoles;
	public numForRole = map contractRole to nat1;
	public budgetPerRole = map contractRole to nat1;
	
values
-- TODO Define values here
instance variables
	private name: Globals`String;
	private contracts: set of Contract;
	private maxNumContracts: nat1;
	private desiredNumPerRole: numForRole;
	private maxPricePerRole: budgetPerRole;
	private desiredCelebTypes: set of Celebrity`celebrityType;
	private duration: nat1;
	inv card contracts <= maxNumContracts; -- the project does not have more contracts than desired
	inv getTotalNumDesiredRoles() <= maxNumContracts;
	inv getTotalNumBudgetedRoles() <= maxNumContracts;
	inv dom desiredNumPerRole = dom maxPricePerRole;
	

-- TODO Define instance variables here
operations
	public Project: Globals`String*nat1*numForRole*budgetPerRole*set of Celebrity`celebrityType*nat1 ==> Project
		Project(n,m,d,b,ct,t) == 
		(
			name := n;
			contracts := {};
			maxNumContracts := m;
			desiredNumPerRole := d;
			maxPricePerRole := b;
			desiredCelebTypes := ct;
			duration := t;
			return self;
		)
		pre d <> {|->} and b <> {|->} and ct <> {} and m > 0-- The project must specify desired roles, budget for those roles, and desired celebrity types
		post name = n and contracts = {} and maxNumContracts = m and desiredNumPerRole = d and maxPricePerRole = b and desiredCelebTypes = ct and duration = t;
		
	public getName: () ==> Globals`String
		getName() == return name
		post RESULT = name;
			
	public getContracts: () ==> set of Contract
		getContracts() == return contracts
		post RESULT = contracts;
		
	public getNumContracts: () ==> nat
		getNumContracts() == return card contracts
		post RESULT = card contracts;
			
	public getMaxNumContracts: () ==> nat1
		getMaxNumContracts() == return maxNumContracts
		post RESULT = maxNumContracts;	
		
	public addContract: Contract ==> ()
		addContract(c) == contracts := contracts union {c}
		pre card contracts < maxNumContracts and c not in set  contracts
		post c in set contracts; 		
			
	public getDuration: () ==> nat1
		getDuration() == return duration
		post RESULT = duration;
		
	-- ----- Desired Roles ----------------------------------------------
	public getDesiredNumPerRole: () ==> numForRole
		getDesiredNumPerRole() == return desiredNumPerRole
		post RESULT = desiredNumPerRole;
		
	public getDesiredNumForRole: contractRole ==> nat
		getDesiredNumForRole(role) ==
		(
			if role not in set dom desiredNumPerRole
			then return 0
			else return desiredNumPerRole(role);
		)
		post RESULT >= 0;
		
	public pure getTotalNumDesiredRoles: () ==> nat
		getTotalNumDesiredRoles() == return getSumDesiredRoles(dom desiredNumPerRole, desiredNumPerRole)
		post RESULT >= 0;
		
	-- auxiliary function that returns the sum of all the keys in a map
	public pure  getSumDesiredRoles: set of contractRole*numForRole ==> nat
		getSumDesiredRoles(roles, numRoleMap) == 
		(
			if roles = {}
			then return 0
			else return let role in set roles
				in 
					numRoleMap(role) + getSumDesiredRoles(roles \ {role}, numRoleMap)
		)
		post RESULT >= 0;
		
	public getDesiredRoles: () ==> set of contractRole
		getDesiredRoles() == return dom desiredNumPerRole;
	-- ----- Desired Roles End -------------------------------------------
	
	-- ----- Desired Types -----------------------------------------------
	
	public getDesiredCelebTypes: () ==> set of Celebrity`celebrityType
		getDesiredCelebTypes() == return desiredCelebTypes
		post RESULT = desiredCelebTypes;
		
	-- ----- Desired Types End -------------------------------------------
		
	-- ----- Budget ------------------------------------------------------
	public getMaxPriceForRole: contractRole ==> nat
		getMaxPriceForRole(role) ==
		(
			if role not in set dom maxPricePerRole
			then return 0
			else return maxPricePerRole(role);
		)
		post RESULT >= 0;
		
	public getBudgetPerRole: () ==> budgetPerRole
		getBudgetPerRole() == return maxPricePerRole;
		
	public pure getTotalNumBudgetedRoles: () ==> nat
		getTotalNumBudgetedRoles() == return card dom maxPricePerRole
		post RESULT >= 0;
		
	public getBudgetedRoles: () ==> set of contractRole
		getBudgetedRoles() == return dom maxPricePerRole;

	-- ----- Budget End --------------------------------------------------
		
	-- ----- Search celebrity --------------------------------------------
	public getAppropriateCelebs: set of Celebrity ==> set of Celebrity
	getAppropriateCelebs(celebs) ==
	(
		return {
			celeb | celeb in set celebs & celeb.getRoles() inter getDesiredRoles() <> {}	
			and celeb.getType() inter getDesiredCelebTypes() <> {} 
		};
	)
	pre desiredNumPerRole <> {|->} and desiredCelebTypes <> {};
	
	public proposeContract: Contract*Celebrity ==> bool
		proposeContract(contract, celeb) == 
		(
			if not (celeb.hasSpaceForNewContract(contract) and celeb.checkIfContractIsGood(contract))
				then return false;
				
			addContract(contract);
			celeb.addContract(contract);
			
			return true;
		)
		pre card contracts < maxNumContracts;
	
	-- ----- Search celebrity End ----------------------------------------

		
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Project