class Mergesort -- from MFES and adapted to order an array of type Contract
	operations
	private pure static getPartContracts: seq of Contract*nat*nat ==> seq of Contract
		getPartContracts(c,i,j) == (
			dcl result: seq of Contract := [];
			dcl k: nat := i;
			while (k<=j) do(
				result := result ^ [c(k)];
				k := k + 1;
			);
			
			return result;
		);
	functions
		public static sortContracts: seq of Contract -> seq of Contract
			sortContracts(s) == (
				Mergesort(s)
			);
			
		private Mergesort: seq of Contract -> seq of Contract
			Mergesort(s) == (
				cases len s:
					0 -> s,
					1 -> s,
					others ->  let halfSize = floor ((len s) /2),
					 s1 = getPartContracts(s,1,halfSize),
					 s2 = getPartContracts(s,halfSize + 1, len s) in Merge(Mergesort(s1), Mergesort(s2))
				end
			);
			
		private Merge(s1, s2: seq of Contract) res : seq of Contract == (
			cases true:
				(s1 = []) -> s2,
				(s2 = []) -> s1,
				(Globals`compareDates((hd s1).getFinalDate(),(hd s2).getFinalDate())) -> [hd s1] ^ Merge(tl s1, s2),
				others -> [hd s2] ^ Merge(s1, tl s2)
				end
			);
end Mergesort